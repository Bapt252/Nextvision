# test_commitment_integration.py
"""
Script de test s√©curis√© pour valider l'int√©gration Commitment-
OBJECTIF: Tester sans impacter le syst√®me Nextvision existant
"""

import asyncio
import sys
import json
from pathlib import Path
import tempfile
from datetime import datetime

# Import du bridge s√©curis√©
try:
    from nextvision.services.parsing.commitment_bridge import CommitmentParsingBridge
except ImportError:
    print("‚ùå Erreur: Impossible d'importer CommitmentParsingBridge")
    print("üí° Assurez-vous que le fichier commitment_bridge.py est dans nextvision/services/parsing/")
    sys.exit(1)

class CommitmentIntegrationTester:
    """Testeur s√©curis√© pour l'int√©gration Commitment-"""
    
    def __init__(self):
        self.bridge = CommitmentParsingBridge({
            "safe_mode": True,
            "fallback_enabled": True,
            "test_mode": True
        })
        self.test_results = []
    
    async def run_safety_tests(self):
        """Suite de tests de s√©curit√© compl√®te"""
        
        print("üß™ " + "="*60)
        print("üîó TESTS DE S√âCURIT√â COMMITMENT INTEGRATION")
        print("üß™ " + "="*60)
        print()
        
        # Test 1: Health Check
        await self._test_health_check()
        
        # Test 2: Connexion parsers
        await self._test_parser_connectivity()
        
        # Test 3: Fallback safety
        await self._test_fallback_safety()
        
        # Test 4: Error handling
        await self._test_error_handling()
        
        # Test 5: Real file parsing (si fichiers disponibles)
        await self._test_real_file_parsing()
        
        # R√©sum√© des tests
        self._print_test_summary()
    
    async def _test_health_check(self):
        """Test 1: V√©rification de sant√©"""
        print("üîç Test 1: Health Check...")
        
        try:
            health = await self.bridge.health_check()
            
            if health["bridge_status"] == "healthy":
                print("  ‚úÖ Bridge en bonne sant√©")
                print(f"  üìä CV Parser: {'‚úÖ' if health['cv_parser_available'] else '‚ùå'}")
                print(f"  üìä Job Parser: {'‚úÖ' if health['job_parser_available'] else '‚ùå'}")
                self.test_results.append(("Health Check", True, "Bridge op√©rationnel"))
            else:
                print(f"  ‚ö†Ô∏è Bridge status: {health['bridge_status']}")
                print(f"  üìù Error: {health.get('error', 'Unknown')}")
                self.test_results.append(("Health Check", False, health.get('error', 'Unknown')))
                
        except Exception as e:
            print(f"  ‚ùå Health check failed: {e}")
            self.test_results.append(("Health Check", False, str(e)))
        
        print()
    
    async def _test_parser_connectivity(self):
        """Test 2: Connectivit√© vers parsers Commitment-"""
        print("üåê Test 2: Connectivit√© Parsers...")
        
        try:
            # Test simple de connectivit√©
            from playwright.async_api import async_playwright
            
            async with async_playwright() as p:
                browser = await p.chromium.launch(headless=True)
                page = await browser.new_page()
                
                # Test CV parser
                try:
                    await page.goto(self.bridge.cv_parser_url, timeout=15000)
                    cv_title = await page.title()
                    print(f"  ‚úÖ CV Parser accessible: {cv_title[:50]}...")
                    cv_ok = True
                except Exception as e:
                    print(f"  ‚ùå CV Parser inaccessible: {e}")
                    cv_ok = False
                
                # Test Job parser  
                try:
                    await page.goto(self.bridge.job_parser_url, timeout=15000)
                    job_title = await page.title()
                    print(f"  ‚úÖ Job Parser accessible: {job_title[:50]}...")
                    job_ok = True
                except Exception as e:
                    print(f"  ‚ùå Job Parser inaccessible: {e}")
                    job_ok = False
                
                await browser.close()
            
            self.test_results.append(("CV Parser Connectivity", cv_ok, "Accessible" if cv_ok else "Inaccessible"))
            self.test_results.append(("Job Parser Connectivity", job_ok, "Accessible" if job_ok else "Inaccessible"))
            
        except ImportError:
            print("  ‚ö†Ô∏è Playwright non install√© - test de connectivit√© ignor√©")
            print("  üí° Installez avec: pip install playwright && playwright install")
            self.test_results.append(("Parser Connectivity", False, "Playwright non install√©"))
        except Exception as e:
            print(f"  ‚ùå Erreur connectivit√©: {e}")
            self.test_results.append(("Parser Connectivity", False, str(e)))
        
        print()
    
    async def _test_fallback_safety(self):
        """Test 3: S√©curit√© du fallback"""
        print("üõ°Ô∏è Test 3: S√©curit√© Fallback...")
        
        # Test avec fichier inexistant
        fake_file = "fichier_totalement_inexistant.pdf"
        
        try:
            result = await self.bridge.parse_cv_safe(fake_file)
            
            if result.get("source") == "fallback_simulation":
                print("  ‚úÖ Fallback CV activ√© automatiquement")
                print(f"  üìä Donn√©es simul√©es g√©n√©r√©es: {len(str(result))} caract√®res")
                fallback_cv_ok = True
            else:
                print(f"  ‚ö†Ô∏è Fallback CV inattendu: {result.get('source')}")
                fallback_cv_ok = False
            
            # Test fallback job
            result_job = await self.bridge.parse_job_safe(fake_file)
            
            if result_job.get("source") == "fallback_simulation":
                print("  ‚úÖ Fallback Job activ√© automatiquement")
                fallback_job_ok = True
            else:
                print(f"  ‚ö†Ô∏è Fallback Job inattendu: {result_job.get('source')}")
                fallback_job_ok = False
            
            self.test_results.append(("Fallback CV Safety", fallback_cv_ok, "Fonctionnel"))
            self.test_results.append(("Fallback Job Safety", fallback_job_ok, "Fonctionnel"))
            
        except Exception as e:
            print(f"  ‚ùå Erreur fallback: {e}")
            self.test_results.append(("Fallback Safety", False, str(e)))
        
        print()
    
    async def _test_error_handling(self):
        """Test 4: Gestion d'erreurs"""
        print("‚ö° Test 4: Gestion d'Erreurs...")
        
        # Test avec diff√©rents cas d'erreur
        error_cases = [
            ("", "Fichier vide"),
            ("/path/invalid/file.pdf", "Chemin invalide"),
            ("not_a_file", "Pas un fichier")
        ]
        
        all_handled = True
        
        for test_file, description in error_cases:
            try:
                result = await self.bridge.parse_cv_safe(test_file)
                
                if not result.get("success", True):
                    print(f"  ‚úÖ {description}: Erreur g√©r√©e proprement")
                else:
                    print(f"  ‚ö†Ô∏è {description}: Devrait √©chouer mais a r√©ussi")
                    all_handled = False
                    
            except Exception as e:
                print(f"  ‚ùå {description}: Exception non g√©r√©e: {e}")
                all_handled = False
        
        self.test_results.append(("Error Handling", all_handled, "Gestion propre des erreurs"))
        print()
    
    async def _test_real_file_parsing(self):
        """Test 5: Parsing avec vrais fichiers (si disponibles)"""
        print("üìÑ Test 5: Parsing Fichiers R√©els...")
        
        # Chercher des fichiers de test dans diff√©rents emplacements
        test_locations = [
            "tests/data/",
            "test_data/", 
            "data/",
            "./",
            "../tests/data/"
        ]
        
        test_files = []
        
        for location in test_locations:
            path = Path(location)
            if path.exists():
                # Chercher fichiers PDF
                test_files.extend(path.glob("*.pdf"))
                test_files.extend(path.glob("*cv*.pdf"))
                test_files.extend(path.glob("*job*.pdf"))
                test_files.extend(path.glob("*test*.pdf"))
        
        if not test_files:
            print("  ‚ö†Ô∏è Aucun fichier de test trouv√©")
            print("  üí° Placez des fichiers PDF dans tests/data/ pour tests complets")
            
            # Cr√©er un fichier de test basique
            await self._create_test_file()
            self.test_results.append(("Real File Parsing", False, "Aucun fichier de test"))
        else:
            print(f"  üìÅ {len(test_files)} fichiers de test trouv√©s")
            
            # Tester avec le premier fichier trouv√©
            test_file = str(test_files[0])
            print(f"  üîç Test avec: {Path(test_file).name}")
            
            try:
                result = await self.bridge.parse_cv_safe(test_file)
                
                if result.get("success"):
                    source = result.get("source", "unknown")
                    print(f"  ‚úÖ Parsing r√©ussi via: {source}")
                    
                    if "data" in result:
                        data = result["data"]
                        if "data" in data:  # Structure Commitment-
                            inner_data = data["data"]
                            exp_count = len(inner_data.get("work_experience", []))
                            print(f"  üìä Exp√©riences extraites: {exp_count}")
                        else:
                            print(f"  üìä Donn√©es extraites: {len(str(data))} caract√®res")
                    
                    real_parsing_ok = True
                else:
                    print(f"  ‚ùå Parsing √©chou√©: {result.get('error')}")
                    real_parsing_ok = False
                
                self.test_results.append(("Real File Parsing", real_parsing_ok, f"Via {source}" if real_parsing_ok else "√âchec"))
                
            except Exception as e:
                print(f"  ‚ùå Erreur parsing r√©el: {e}")
                self.test_results.append(("Real File Parsing", False, str(e)))
        
        print()
    
    async def _create_test_file(self):
        """Cr√©er un fichier de test basique"""
        print("  üìù Cr√©ation fichier de test basique...")
        
        try:
            test_dir = Path("tests/data")
            test_dir.mkdir(parents=True, exist_ok=True)
            
            # Cr√©er un fichier texte simulant un CV
            test_cv_content = """
CV Test - Jean Dupont
Email: jean.dupont@example.com
T√©l√©phone: 01 23 45 67 89

EXP√âRIENCE PROFESSIONNELLE

2020-2023: D√©veloppeur Full Stack
Entreprise Tech, Paris
- D√©veloppement applications web
- Technologies: JavaScript, Python, React

2018-2020: D√©veloppeur Junior  
StartUp Innovation, Lyon
- Maintenance applications
- Formation aux nouvelles technologies

FORMATION

2018: Master Informatique
Universit√© de Lyon

COMP√âTENCES
- JavaScript, Python, React
- Base de donn√©es SQL
- Git, Docker
            """
            
            test_file = test_dir / "cv_test.txt"
            test_file.write_text(test_cv_content, encoding='utf-8')
            
            print(f"  ‚úÖ Fichier de test cr√©√©: {test_file}")
            
        except Exception as e:
            print(f"  ‚ö†Ô∏è Impossible de cr√©er fichier de test: {e}")
    
    def _print_test_summary(self):
        """Afficher le r√©sum√© des tests"""
        print("üìä " + "="*60)
        print("ÔøΩÔøΩ R√âSUM√â DES TESTS DE S√âCURIT√â")
        print("üìä " + "="*60)
        
        total_tests = len(self.test_results)
        passed_tests = sum(1 for _, success, _ in self.test_results if success)
        
        print(f"\nüéØ Tests pass√©s: {passed_tests}/{total_tests}")
        
        if passed_tests == total_tests:
            print("‚úÖ TOUS LES TESTS PASS√âS - INT√âGRATION S√âCURIS√âE !")
        elif passed_tests >= total_tests * 0.8:
            print("‚ö†Ô∏è MAJORIT√â DES TESTS PASS√âS - INT√âGRATION ACCEPTABLE")
        else:
            print("‚ùå PLUSIEURS TESTS √âCHOU√âS - R√âVISION N√âCESSAIRE")
        
        print("\nüìã D√©tail des tests:")
        for test_name, success, details in self.test_results:
            status = "‚úÖ" if success else "‚ùå"
            print(f"  {status} {test_name}: {details}")
        
        # Statistiques du bridge
        stats = self.bridge.get_stats()
        print(f"\nüìà Statistiques Bridge:")
        print(f"  ‚Ä¢ Taux de succ√®s: {stats['success_rate']:.1f}%")
        print(f"  ‚Ä¢ Taux de fallback: {stats['fallback_rate']:.1f}%")
        print(f"  ‚Ä¢ Parsing CV: {stats['cv_parses']}")
        print(f"  ‚Ä¢ Parsing Jobs: {stats['job_parses']}")
        
        print("\nüîß Recommandations:")
        if passed_tests == total_tests:
            print("  ‚úÖ Le bridge est pr√™t pour l'int√©gration avec Enhanced Bridge V3.0")
            print("  üöÄ Vous pouvez proc√©der √† l'√©tape suivante en toute s√©curit√©")
        else:
            print("  ‚ö†Ô∏è R√©soudre les probl√®mes identifi√©s avant int√©gration")
            if stats['fallback_rate'] > 50:
                print("  üí° V√©rifiez la connectivit√© vers Commitment- parsers")
        
        print("\nüéâ Tests de s√©curit√© termin√©s !")

# Interface de test simple
async def main():
    """Point d'entr√©e principal"""
    
    print(f"üïí D√©but des tests: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    # V√©rifier les d√©pendances
    try:
        import playwright
        print("‚úÖ Playwright disponible")
    except ImportError:
        print("‚ö†Ô∏è Playwright non install√©")
        print("üí° Pour des tests complets, installez: pip install playwright && playwright install")
    
    # Lancer les tests
    tester = CommitmentIntegrationTester()
    await tester.run_safety_tests()

# Tests en mode script
if __name__ == "__main__":
    print("üîó COMMITMENT INTEGRATION - TESTS DE S√âCURIT√â")
    print("=" * 60)
    print()
    
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Tests interrompus par l'utilisateur")
    except Exception as e:
        print(f"\n‚ùå Erreur critique dans les tests: {e}")
        sys.exit(1)
