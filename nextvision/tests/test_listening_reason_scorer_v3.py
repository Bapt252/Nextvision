"""
üß™ Tests ListeningReasonScorer V3.0
===================================

Tests de validation du scorer raisons d'√©coute int√©gr√© dans scorers_v3/
- Performance <4ms target (2% budget)
- Coh√©rence raisons d'√©coute vs profil candidat
- Interaction avec pond√©ration adaptative
- Gestion erreurs et fallbacks

Author: NEXTEN Team
Version: 3.0.0 - Test Suite
"""

import time
import logging
from typing import Dict, Any, List

# Configuration logging pour tests
logging.basicConfig(level=logging.INFO)

# Import des mod√®les V3.0
from nextvision.models.extended_bidirectional_models_v3 import (
    ExtendedCandidateProfileV3,
    ExtendedCompanyProfileV3,
    CandidateStatusType,
    WorkModalityType,
    CompanySize
)

# Import des mod√®les V2.0 (pour base)
from nextvision.models.bidirectional_models import (
    BiDirectionalCandidateProfile,
    BiDirectionalCompanyProfile,
    EntrepriseInfo,
    DescriptionPoste,
    AttentesCandidat,
    Competences,
    MotivationsCandidat
)

# Import configuration adaptative
from nextvision.config.adaptive_weighting_config import (
    ListeningReasonType,
    ADAPTIVE_MATRICES_V3
)

# Import scorer
from nextvision.services.scorers_v3.listening_reason_scorer import ListeningReasonScorer

def create_test_candidate_coherent() -> ExtendedCandidateProfileV3:
    """üéØ Candidat test avec raisons d'√©coute coh√©rentes"""
    
    # Base V2.0
    base_profile = BiDirectionalCandidateProfile(
        competences=Competences(),
        attentes=AttentesCandidat(
            salaire_min=45000,
            salaire_max=60000
        ),
        motivations=MotivationsCandidat()
    )
    
    candidate = ExtendedCandidateProfileV3(base_profile=base_profile)
    
    # Raisons d'√©coute coh√©rentes
    candidate.availability_timing.listening_reasons = [
        ListeningReasonType.REMUNERATION_FAIBLE,  # Primaire
        ListeningReasonType.MANQUE_PERSPECTIVES   # Secondaire coh√©rente
    ]
    
    # Donn√©es coh√©rentes
    candidate.availability_timing.employment_status = CandidateStatusType.EN_POSTE
    candidate.availability_timing.current_salary = 38000  # En dessous du min souhait√©
    candidate.transport_preferences.office_preference = WorkModalityType.ON_SITE
    
    return candidate

def create_test_candidate_incoherent() -> ExtendedCandidateProfileV3:
    """‚ùå Candidat test avec raisons d'√©coute incoh√©rentes"""
    
    base_profile = BiDirectionalCandidateProfile(
        competences=Competences(),
        attentes=AttentesCandidat(
            salaire_min=50000,
            salaire_max=52000  # √âcart faible
        ),
        motivations=MotivationsCandidat()
    )
    
    candidate = ExtendedCandidateProfileV3(base_profile=base_profile)
    
    # Raisons incoh√©rentes
    candidate.availability_timing.listening_reasons = [
        ListeningReasonType.REMUNERATION_FAIBLE,  # Primaire
        ListeningReasonType.FLEXIBILITE           # Secondaire incoh√©rente
    ]
    
    # Donn√©es incoh√©rentes
    candidate.availability_timing.employment_status = CandidateStatusType.DEMANDEUR_EMPLOI
    candidate.availability_timing.current_salary = 55000  # Au-dessus du min souhait√©
    
    return candidate

def create_test_candidate_flexibility() -> ExtendedCandidateProfileV3:
    """üîÑ Candidat test avec focus flexibilit√©"""
    
    base_profile = BiDirectionalCandidateProfile(
        competences=Competences(),
        attentes=AttentesCandidat(),
        motivations=MotivationsCandidat()
    )
    
    candidate = ExtendedCandidateProfileV3(base_profile=base_profile)
    
    # Raisons flexibilit√©
    candidate.availability_timing.listening_reasons = [
        ListeningReasonType.FLEXIBILITE,
        ListeningReasonType.LOCALISATION
    ]
    
    # Donn√©es coh√©rentes flexibilit√©
    candidate.availability_timing.employment_status = CandidateStatusType.EN_POSTE
    candidate.transport_preferences.office_preference = WorkModalityType.FULL_REMOTE
    candidate.transport_preferences.max_travel_time = 20  # Temps trajet court
    
    return candidate

def create_test_company() -> ExtendedCompanyProfileV3:
    """üè¢ Entreprise test standard"""
    
    base_profile = BiDirectionalCompanyProfile(
        entreprise=EntrepriseInfo(
            nom="TechCorp",
            secteur="Technologie"
        ),
        poste=DescriptionPoste(
            titre="Software Engineer",
            description="Poste avec √©volution possible"
        )
    )
    
    company = ExtendedCompanyProfileV3(base_profile=base_profile)
    company.company_profile_v3.company_size = CompanySize.STARTUP
    
    return company

def test_listening_reason_performance():
    """‚ö° Test performance <4ms"""
    
    print("üöÄ TEST PERFORMANCE LISTENING REASON SCORER")
    print("=" * 50)
    
    scorer = ListeningReasonScorer()
    candidate = create_test_candidate_coherent()
    company = create_test_company()
    
    # Test performance avec 15 calculs
    times = []
    for i in range(15):
        start = time.time()
        result = scorer.calculate_listening_reason_score(candidate, company)
        processing_time = (time.time() - start) * 1000
        times.append(processing_time)
        
        print(f"  Calcul #{i+1}: {processing_time:.2f}ms - Score: {result['final_score']:.3f}")
    
    avg_time = sum(times) / len(times)
    max_time = max(times)
    min_time = min(times)
    
    print(f"\nüìä R√âSULTATS PERFORMANCE:")
    print(f"  ‚Ä¢ Temps moyen: {avg_time:.2f}ms")
    print(f"  ‚Ä¢ Temps max: {max_time:.2f}ms")
    print(f"  ‚Ä¢ Temps min: {min_time:.2f}ms")
    print(f"  ‚Ä¢ Target <4ms: {'‚úÖ ATTEINT' if max_time < 4 else '‚ùå √âCHEC'}")
    
    return max_time < 4.0

def test_coherence_analysis():
    """üß† Test analyse coh√©rence"""
    
    print("\nüß† TEST ANALYSE COH√âRENCE")
    print("=" * 50)
    
    scorer = ListeningReasonScorer()
    
    # Test candidat coh√©rent
    candidate_coherent = create_test_candidate_coherent()
    company = create_test_company()
    
    result_coherent = scorer.calculate_listening_reason_score(candidate_coherent, company)
    
    print(f"üìä CANDIDAT COH√âRENT:")
    print(f"  ‚Ä¢ Score: {result_coherent['final_score']:.3f}")
    print(f"  ‚Ä¢ Niveau: {result_coherent['coherence_level']}")
    print(f"  ‚Ä¢ Raison primaire: {result_coherent['listening_reasons_analysis']['primary_reason']}")
    print(f"  ‚Ä¢ Raisons secondaires: {result_coherent['listening_reasons_analysis']['secondary_reasons']}")
    
    # Test candidat incoh√©rent  
    candidate_incoherent = create_test_candidate_incoherent()
    result_incoherent = scorer.calculate_listening_reason_score(candidate_incoherent, company)
    
    print(f"\nüìä CANDIDAT INCOH√âRENT:")
    print(f"  ‚Ä¢ Score: {result_incoherent['final_score']:.3f}")
    print(f"  ‚Ä¢ Niveau: {result_incoherent['coherence_level']}")
    
    # Comparaison
    coherence_gap = result_coherent['final_score'] - result_incoherent['final_score']
    print(f"\nüîç ANALYSE COMPARATIVE:")
    print(f"  ‚Ä¢ √âcart coh√©rence: {coherence_gap:.3f}")
    print(f"  ‚Ä¢ Discrimination: {'‚úÖ EFFICACE' if coherence_gap > 0.2 else '‚ùå FAIBLE'}")
    
    return coherence_gap > 0.1

def test_adaptive_impact():
    """üéØ Test impact pond√©ration adaptative"""
    
    print("\nüéØ TEST IMPACT POND√âRATION ADAPTATIVE")
    print("=" * 50)
    
    scorer = ListeningReasonScorer()
    
    # Test diff√©rentes raisons d'√©coute
    test_cases = [
        (ListeningReasonType.REMUNERATION_FAIBLE, "R√©mun√©ration faible"),
        (ListeningReasonType.MANQUE_PERSPECTIVES, "Manque perspectives"),
        (ListeningReasonType.FLEXIBILITE, "Flexibilit√©"),
        (ListeningReasonType.LOCALISATION, "Localisation"),
        (ListeningReasonType.POSTE_INADEQUAT, "Poste inad√©quat")
    ]
    
    for reason, description in test_cases:
        # Test impact
        adaptive_impact = scorer.get_adaptive_impact_preview([reason])
        
        print(f"üìä {description.upper()}:")
        print(f"  ‚Ä¢ Impact adaptatif: {adaptive_impact['has_impact']}")
        
        if adaptive_impact['has_impact']:
            print(f"  ‚Ä¢ Changements majeurs: {adaptive_impact['major_changes']}")
        
        # Test avec candidat r√©el
        candidate = create_test_candidate_coherent()
        candidate.availability_timing.listening_reasons = [reason]
        
        result = scorer.calculate_listening_reason_score(candidate, create_test_company())
        impact_details = result['adaptive_impact']
        
        print(f"  ‚Ä¢ Boost d√©tect√©: {impact_details['has_adaptive_impact']}")
        if impact_details['has_adaptive_impact']:
            boosted = impact_details.get('boosted_components', [])
            if boosted:
                print(f"  ‚Ä¢ Top boost: {boosted[0]['component']} ({boosted[0]['boost_factor']:.1f}x)")
    
    return True

def test_multiple_reasons():
    """üîó Test raisons multiples"""
    
    print("\nüîó TEST RAISONS MULTIPLES")
    print("=" * 50)
    
    scorer = ListeningReasonScorer()
    company = create_test_company()
    
    # Test raisons simples vs multiples
    test_cases = [
        {
            "name": "Raison simple",
            "reasons": [ListeningReasonType.REMUNERATION_FAIBLE],
            "expected_boost": False
        },
        {
            "name": "Raisons coh√©rentes",
            "reasons": [ListeningReasonType.REMUNERATION_FAIBLE, ListeningReasonType.MANQUE_PERSPECTIVES],
            "expected_boost": True
        },
        {
            "name": "Raisons incoh√©rentes",
            "reasons": [ListeningReasonType.REMUNERATION_FAIBLE, ListeningReasonType.FLEXIBILITE],
            "expected_boost": False
        },
        {
            "name": "Raisons multiples",
            "reasons": [ListeningReasonType.FLEXIBILITE, ListeningReasonType.LOCALISATION, ListeningReasonType.MANQUE_PERSPECTIVES],
            "expected_boost": True
        }
    ]
    
    results = []
    
    for case in test_cases:
        candidate = create_test_candidate_coherent()
        candidate.availability_timing.listening_reasons = case["reasons"]
        
        result = scorer.calculate_listening_reason_score(candidate, company)
        
        print(f"üìä {case['name'].upper()}:")
        print(f"  ‚Ä¢ Raisons: {[r.value for r in case['reasons']]}")
        print(f"  ‚Ä¢ Score: {result['final_score']:.3f}")
        print(f"  ‚Ä¢ Niveau: {result['coherence_level']}")
        print(f"  ‚Ä¢ Facteurs: {len(result['coherence_factors'])}")
        
        results.append({
            "name": case["name"],
            "score": result['final_score'],
            "coherence_level": result['coherence_level']
        })
    
    # V√©rification progression logique
    simple_score = results[0]['score']
    coherent_score = results[1]['score']
    
    print(f"\nüîç ANALYSE PROGRESSION:")
    print(f"  ‚Ä¢ Simple ‚Üí Coh√©rent: {coherent_score - simple_score:.3f}")
    print(f"  ‚Ä¢ Bonus coh√©rence: {'‚úÖ D√âTECT√â' if coherent_score > simple_score else '‚ùå MANQU√â'}")
    
    return coherent_score > simple_score

def test_error_handling():
    """üö® Test gestion erreurs"""
    
    print("\nüö® TEST GESTION ERREURS")
    print("=" * 50)
    
    scorer = ListeningReasonScorer()
    
    # Test candidat sans raisons d'√©coute
    try:
        base_profile = BiDirectionalCandidateProfile(
            competences=Competences(),
            attentes=AttentesCandidat(),
            motivations=MotivationsCandidat()
        )
        empty_candidate = ExtendedCandidateProfileV3(base_profile=base_profile)
        empty_candidate.availability_timing.listening_reasons = []
        
        company = create_test_company()
        
        result = scorer.calculate_listening_reason_score(empty_candidate, company)
        
        print(f"üìä CANDIDAT SANS RAISONS:")
        print(f"  ‚Ä¢ Score: {result['final_score']:.3f}")
        print(f"  ‚Ä¢ Version: {result.get('version', 'normal')}")
        print(f"  ‚Ä¢ Erreur g√©r√©e: {'error' in result}")
        
        # Test avec raisons vides explicites
        result_empty = scorer.get_adaptive_impact_preview([])
        print(f"\nüìä IMPACT RAISONS VIDES:")
        print(f"  ‚Ä¢ Impact: {result_empty['has_impact']}")
        print(f"  ‚Ä¢ Message: {result_empty['message']}")
        
        return 'error' in result or result['final_score'] == 0.5
        
    except Exception as e:
        print(f"‚ùå Erreur non g√©r√©e: {e}")
        return False

def test_performance_stats():
    """üìä Test statistiques performance"""
    
    print("\nüìä TEST STATISTIQUES PERFORMANCE")
    print("=" * 50)
    
    scorer = ListeningReasonScorer()
    company = create_test_company()
    
    # G√©n√©ration de quelques calculs
    candidates = [
        create_test_candidate_coherent(),
        create_test_candidate_incoherent(),
        create_test_candidate_flexibility()
    ]
    
    for i, candidate in enumerate(candidates):
        result = scorer.calculate_listening_reason_score(candidate, company)
        print(f"  Calcul test #{i+1}: {result['final_score']:.3f} - {result['coherence_level']}")
    
    # R√©cup√©ration statistiques
    stats = scorer.get_performance_stats()
    
    print(f"\nüìà STATISTIQUES SCORER:")
    print(f"  ‚Ä¢ Calculs effectu√©s: {stats['scorer_stats']['calculations']}")
    print(f"  ‚Ä¢ Temps moyen: {stats['performance_metrics']['average_processing_time_ms']:.2f}ms")
    print(f"  ‚Ä¢ Target atteint: {stats['performance_metrics']['target_achieved']}")
    
    # Distribution coh√©rence
    coherence_rates = stats['performance_metrics']['coherence_rates']
    print(f"\nüìä DISTRIBUTION COH√âRENCE:")
    for level, rate in coherence_rates.items():
        print(f"  ‚Ä¢ {level}: {rate:.1%}")
    
    return stats['performance_metrics']['target_achieved']

def run_full_test_suite():
    """üß™ Suite compl√®te de tests"""
    
    print("üß™ SUITE TESTS LISTENING REASON SCORER V3.0")
    print("=" * 60)
    
    tests = [
        ("Performance <4ms", test_listening_reason_performance),
        ("Analyse coh√©rence", test_coherence_analysis),
        ("Impact adaptatif", test_adaptive_impact),
        ("Raisons multiples", test_multiple_reasons),
        ("Gestion erreurs", test_error_handling),
        ("Statistiques", test_performance_stats)
    ]
    
    results = []
    
    for test_name, test_func in tests:
        try:
            success = test_func()
            results.append((test_name, success))
            print(f"\n{'‚úÖ' if success else '‚ùå'} {test_name}: {'SUCC√àS' if success else '√âCHEC'}")
        except Exception as e:
            results.append((test_name, False))
            print(f"\n‚ùå {test_name}: ERREUR - {e}")
    
    # R√©sum√© final
    passed = sum(1 for _, success in results if success)
    total = len(results)
    
    print("\n" + "=" * 60)
    print(f"üìà R√âSULTATS FINAUX: {passed}/{total} tests r√©ussis")
    
    if passed == total:
        print("üéâ TOUS LES TESTS PASS√âS - LISTENING REASON SCORER OP√âRATIONNEL!")
        print("\nüöÄ PR√äT POUR INT√âGRATION PRODUCTION:")
        print("  ‚úÖ Performance <4ms valid√©e")
        print("  ‚úÖ Analyse coh√©rence fonctionnelle")
        print("  ‚úÖ Impact adaptatif confirm√©")
        print("  ‚úÖ Raisons multiples support√©es")
        print("  ‚úÖ Gestion erreurs robuste")
        print("  ‚úÖ Statistiques compl√®tes")
        print("\nüéØ IMPACT SYST√àME V3.0:")
        print("  ‚Ä¢ 6/12 scorers maintenant op√©rationnels")
        print("  ‚Ä¢ 32% du poids total couvert")
        print("  ‚Ä¢ Cerveau adaptatif (2%) int√©gr√©")
        print("  ‚Ä¢ Interaction avec pond√©ration adaptative active")
    else:
        print(f"‚ö†Ô∏è {total - passed} tests en √©chec - Corrections n√©cessaires")
    
    return passed == total

if __name__ == "__main__":
    # Ex√©cution suite compl√®te
    success = run_full_test_suite()
    
    if success:
        print("\nüß† LISTENING REASON SCORER V3.0 VALID√â!")
        print("üì¶ Package scorers_v3/ mis √† jour avec succ√®s")
        print("üéØ Cerveau adaptatif du syst√®me V3.0 op√©rationnel")
        print("‚ö° Impact sur pond√©ration adaptative confirm√©")
    else:
        print("\nüîß Corrections n√©cessaires avant int√©gration")
