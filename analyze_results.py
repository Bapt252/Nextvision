#!/usr/bin/env python3
"""
üéØ Nextvision Results Analyzer - Visualiseur de r√©sultats de matching
Analyse et affiche les r√©sultats d√©taill√©s des tests Nextvision V3.0

Author: Assistant  
Version: 1.1 - Fixed data structure handling
"""

import json
import sys
from pathlib import Path
from typing import Dict, List, Any
import glob

# Couleurs pour l'affichage
class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    END = '\033[0m'

def find_latest_report() -> Path:
    """Trouve le rapport le plus r√©cent"""
    reports = glob.glob("nextvision_real_data_test_report_*.json")
    if not reports:
        print(f"{Colors.RED}‚ùå Aucun rapport trouv√©{Colors.END}")
        sys.exit(1)
    
    latest = max(reports, key=lambda x: Path(x).stat().st_mtime)
    return Path(latest)

def load_report(report_path: Path) -> Dict:
    """Charge le rapport JSON"""
    try:
        with open(report_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        print(f"{Colors.RED}‚ùå Erreur lecture rapport: {e}{Colors.END}")
        sys.exit(1)

def safe_get(obj, *keys, default=None):
    """Acc√®s s√©curis√© aux cl√©s imbriqu√©es"""
    for key in keys:
        if isinstance(obj, dict):
            obj = obj.get(key, default)
        else:
            return default
    return obj

def display_summary(data: Dict):
    """Affiche le r√©sum√© g√©n√©ral"""
    summary = data.get('test_summary', {})
    metrics = data.get('performance_metrics', {})
    
    print(f"{Colors.BOLD}{Colors.CYAN}üìä === R√âSUM√â NEXTVISION V3.0 ==={Colors.END}")
    print(f"{Colors.BOLD}‚è±Ô∏è  Dur√©e totale : {Colors.GREEN}{summary.get('total_duration', 0):.2f}s{Colors.END}")
    print(f"{Colors.BOLD}üìÅ Fichiers test√©s : {Colors.BLUE}{summary.get('files_tested', 0)}{Colors.END}")
    print(f"{Colors.BOLD}‚úÖ Tests r√©ussis : {Colors.GREEN}{summary.get('successful_tests', 0)}{Colors.END}")
    print(f"{Colors.BOLD}‚ùå Tests √©chou√©s : {Colors.RED}{summary.get('failed_tests', 0)}{Colors.END}")
    print(f"{Colors.BOLD}üìä Taux de r√©ussite : {Colors.GREEN}{metrics.get('success_rate', 0):.1f}%{Colors.END}")
    print()

def display_file_discovery(data: Dict):
    """Affiche la d√©couverte des fichiers"""
    discovery = data.get('file_discovery', {})
    
    print(f"{Colors.BOLD}{Colors.YELLOW}üìÅ === D√âCOUVERTE FICHIERS ==={Colors.END}")
    print(f"üìÑ CVs trouv√©s : {Colors.GREEN}{len(discovery.get('cv_files', []))}{Colors.END}")
    print(f"üìã FDPs trouv√©es : {Colors.GREEN}{len(discovery.get('fdp_files', []))}{Colors.END}")
    print(f"üìÇ Total fichiers : {Colors.BLUE}{discovery.get('total_files', 0)}{Colors.END}")
    print()

def display_cv_results(data: Dict):
    """Affiche les r√©sultats de parsing CV"""
    cv_tests = data.get('test_results', {}).get('cv_tests', [])
    
    print(f"{Colors.BOLD}{Colors.BLUE}ü§ñ === R√âSULTATS PARSING CV ==={Colors.END}")
    
    if not cv_tests:
        print(f"‚ö†Ô∏è Aucun test CV trouv√©")
        print()
        return
    
    # Validation et conversion s√©curis√©e
    successful_cvs = []
    failed_cvs = []
    
    for test in cv_tests:
        if isinstance(test, dict):
            parsing_result = test.get('parsing_result')
            if isinstance(parsing_result, dict):
                if parsing_result.get('success', False):
                    successful_cvs.append(test)
                else:
                    failed_cvs.append(test)
            else:
                # Donn√©es non structur√©es comme attendu
                failed_cvs.append(test)
        else:
            print(f"‚ö†Ô∏è Structure de donn√©es inattendue: {type(test)}")
    
    print(f"‚úÖ CVs pars√©s avec succ√®s : {Colors.GREEN}{len(successful_cvs)}{Colors.END}")
    print(f"‚ùå √âchecs parsing CV : {Colors.RED}{len(failed_cvs)}{Colors.END}")
    print()
    
    if successful_cvs:
        print(f"{Colors.BOLD}üìã Top 5 CVs analys√©s :{Colors.END}")
        for i, cv in enumerate(successful_cvs[:5]):
            name = safe_get(cv, 'file_name', default='Unknown')
            size = safe_get(cv, 'file_size', default=0) / 1024  # KB
            time_ms = safe_get(cv, 'parsing_result', 'processing_time', default=0) * 1000
            print(f"  {i+1}. {name}")
            print(f"     üìè Taille: {size:.1f} KB | ‚è±Ô∏è Temps: {time_ms:.1f}ms")
            
            # D√©tails du parsing si disponibles
            parsing_result = safe_get(cv, 'parsing_result', 'details', 'parsing_result', default={})
            if parsing_result:
                competences = safe_get(parsing_result, 'competences', default=[])
                exp = safe_get(parsing_result, 'experience', 'annees_experience', default=0)
                print(f"     üíº Exp√©rience: {exp} ans | üîß Comp√©tences: {len(competences)}")
        print()

def display_fdp_results(data: Dict):
    """Affiche les r√©sultats de parsing FDP"""
    fdp_tests = data.get('test_results', {}).get('fdp_tests', [])
    
    print(f"{Colors.BOLD}{Colors.MAGENTA}üß† === R√âSULTATS PARSING FDP ==={Colors.END}")
    
    if not fdp_tests:
        print(f"‚ö†Ô∏è Aucun test FDP trouv√©")
        print()
        return
    
    # Validation et conversion s√©curis√©e
    successful_fdps = []
    failed_fdps = []
    
    for test in fdp_tests:
        if isinstance(test, dict):
            parsing_result = test.get('parsing_result')
            if isinstance(parsing_result, dict):
                if parsing_result.get('success', False):
                    successful_fdps.append(test)
                else:
                    failed_fdps.append(test)
            else:
                failed_fdps.append(test)
    
    print(f"‚úÖ FDPs pars√©es avec succ√®s : {Colors.GREEN}{len(successful_fdps)}{Colors.END}")
    print(f"‚ùå √âchecs parsing FDP : {Colors.RED}{len(failed_fdps)}{Colors.END}")
    print()
    
    if successful_fdps:
        print(f"{Colors.BOLD}üìã Top 5 FDPs analys√©es :{Colors.END}")
        for i, fdp in enumerate(successful_fdps[:5]):
            name = safe_get(fdp, 'file_name', default='Unknown')
            size = safe_get(fdp, 'file_size', default=0) / 1024  # KB
            time_ms = safe_get(fdp, 'parsing_result', 'processing_time', default=0) * 1000
            print(f"  {i+1}. {name}")
            print(f"     üìè Taille: {size:.1f} KB | ‚è±Ô∏è Temps: {time_ms:.1f}ms")
            
            # D√©tails du parsing si disponibles
            parsing_result = safe_get(fdp, 'parsing_result', 'details', 'parsing_result', default={})
            if parsing_result:
                titre = safe_get(parsing_result, 'titre_poste', default='N/A')
                salaire = safe_get(parsing_result, 'salaire', default={})
                print(f"     üíº Poste: {titre}")
                if salaire:
                    sal_min = safe_get(salaire, 'min', default=0)
                    sal_max = safe_get(salaire, 'max', default=0)
                    print(f"     üí∞ Salaire: {sal_min}-{sal_max} EUR")
        print()

def display_matching_results(data: Dict):
    """Affiche les r√©sultats de matching avec recommandations"""
    matching_tests = data.get('test_results', {}).get('matching_tests', [])
    
    print(f"{Colors.BOLD}{Colors.CYAN}üéØ === R√âSULTATS MATCHING ==={Colors.END}")
    
    if not matching_tests:
        print(f"‚ö†Ô∏è Aucun test de matching trouv√©")
        print()
        return
    
    # Validation s√©curis√©e
    successful_matches = []
    for test in matching_tests:
        if isinstance(test, dict) and test.get('success', False):
            successful_matches.append(test)
    
    print(f"‚úÖ Matchings r√©ussis : {Colors.GREEN}{len(successful_matches)}{Colors.END}")
    print()
    
    if successful_matches:
        print(f"{Colors.BOLD}üèÜ TOP MATCHINGS RECOMMAND√âS :{Colors.END}")
        
        # Trier par score (si disponible dans les d√©tails)
        scored_matches = []
        for match in successful_matches:
            score = safe_get(match, 'details', 'matching_results', 'total_score', default=0)
            scored_matches.append((match, score))
        
        scored_matches.sort(key=lambda x: x[1], reverse=True)
        
        for i, (match, score) in enumerate(scored_matches[:10]):
            message = match.get('message', 'N/A')
            time_ms = match.get('processing_time', 0) * 1000
            
            print(f"{Colors.BOLD}#{i+1} - Score: {Colors.GREEN}{score:.2f}{Colors.END}")
            print(f"     üîó {message}")
            print(f"     ‚è±Ô∏è Temps: {time_ms:.1f}ms")
            
            # D√©tails du matching
            matching_results = safe_get(match, 'details', 'matching_results', default={})
            if matching_results:
                confidence = matching_results.get('confidence', 0)
                print(f"     üìä Confiance: {confidence:.2f}")
                
                # Scores par composant
                component_scores = matching_results.get('component_scores', {})
                if component_scores:
                    print(f"     üìà D√©tail scores:")
                    for component, comp_score in component_scores.items():
                        print(f"        ‚Ä¢ {component}: {comp_score:.2f}")
            print()

def display_transport_results(data: Dict):
    """Affiche les r√©sultats de transport intelligence"""
    transport_tests = data.get('test_results', {}).get('transport_tests', [])
    
    print(f"{Colors.BOLD}{Colors.GREEN}üöó === TRANSPORT INTELLIGENCE ==={Colors.END}")
    
    if not transport_tests:
        print(f"‚ö†Ô∏è Aucun test de transport trouv√©")
        print()
        return
    
    # Validation s√©curis√©e
    successful_transport = []
    for test in transport_tests:
        if isinstance(test, dict) and test.get('success', False):
            successful_transport.append(test)
    
    print(f"‚úÖ Tests transport r√©ussis : {Colors.GREEN}{len(successful_transport)}{Colors.END}")
    print()
    
    if successful_transport:
        print(f"{Colors.BOLD}üö¶ R√âSULTATS COMPATIBILIT√â TRANSPORT :{Colors.END}")
        
        for i, test in enumerate(successful_transport):
            message = test.get('message', 'N/A')
            time_ms = test.get('processing_time', 0) * 1000
            
            print(f"{Colors.BOLD}Test {i+1}: {message}{Colors.END}")
            print(f"‚è±Ô∏è Temps: {time_ms:.1f}ms")
            
            # D√©tails du transport
            compatibility_result = safe_get(test, 'details', 'compatibility_result', default={})
            if compatibility_result:
                is_compatible = compatibility_result.get('is_compatible', False)
                compat_score = compatibility_result.get('compatibility_score', 0)
                recommended_mode = compatibility_result.get('recommended_mode', 'N/A')
                
                status_color = Colors.GREEN if is_compatible else Colors.RED
                print(f"üö¶ Compatible: {status_color}{is_compatible}{Colors.END}")
                print(f"üìä Score: {compat_score:.2f}")
                print(f"üöó Mode recommand√©: {recommended_mode}")
                
                # D√©tails par mode de transport
                transport_details = compatibility_result.get('transport_details', {})
                if transport_details:
                    print(f"üìã D√©tails par mode:")
                    for mode, mode_details in transport_details.items():
                        if isinstance(mode_details, dict):
                            time_min = mode_details.get('time_minutes', 0)
                            cost = mode_details.get('cost_per_day', 0)
                            compatible = mode_details.get('is_compatible', False)
                            status = "‚úÖ" if compatible else "‚ùå"
                            print(f"   {status} {mode}: {time_min}min, {cost:.2f}‚Ç¨/jour")
            print()

def display_api_health(data: Dict):
    """Affiche l'√©tat des APIs"""
    api_health = data.get('api_health', {})
    
    print(f"{Colors.BOLD}{Colors.YELLOW}‚ù§Ô∏è === √âTAT DES APIS ==={Colors.END}")
    
    for service, status in api_health.items():
        status_color = Colors.GREEN if status else Colors.RED
        status_text = "‚úÖ OK" if status else "‚ùå NON DISPONIBLE"
        print(f"  ‚Ä¢ {service}: {status_color}{status_text}{Colors.END}")
    print()

def display_raw_data_sample(data: Dict):
    """Affiche un √©chantillon des donn√©es brutes pour debug"""
    print(f"{Colors.BOLD}{Colors.YELLOW}üîç === √âCHANTILLON DONN√âES BRUTES ==={Colors.END}")
    
    test_results = data.get('test_results', {})
    for category, tests in test_results.items():
        if tests:
            print(f"\n{category}: {len(tests)} √©l√©ments")
            first_test = tests[0] if tests else None
            if first_test:
                print(f"Structure du premier √©l√©ment: {type(first_test)}")
                if isinstance(first_test, dict):
                    print(f"Cl√©s disponibles: {list(first_test.keys())}")
                else:
                    print(f"Valeur: {first_test}")
    print()

def main():
    """Point d'entr√©e principal"""
    print(f"{Colors.BOLD}{Colors.MAGENTA}üéØ NEXTVISION RESULTS ANALYZER v1.1{Colors.END}")
    print(f"{Colors.BLUE}Analyse des r√©sultats de test Nextvision V3.0{Colors.END}")
    print()
    
    # Trouver le rapport le plus r√©cent
    report_path = find_latest_report()
    print(f"üìÑ Analyse du rapport: {Colors.GREEN}{report_path}{Colors.END}")
    print()
    
    # Charger les donn√©es
    data = load_report(report_path)
    
    # Affichage des r√©sultats
    display_summary(data)
    display_file_discovery(data)
    display_api_health(data)
    
    # Debug: voir la structure des donn√©es
    display_raw_data_sample(data)
    
    display_cv_results(data)
    display_fdp_results(data)
    display_matching_results(data)
    display_transport_results(data)
    
    print(f"{Colors.BOLD}{Colors.CYAN}üéâ === ANALYSE TERMIN√âE ==={Colors.END}")
    print(f"üìÑ Rapport complet disponible dans: {report_path}")
    print(f"üîç Logs d√©taill√©s dans: nextvision_test.log")

if __name__ == "__main__":
    main()
