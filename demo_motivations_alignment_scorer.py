#!/usr/bin/env python3
"""
Script de d√©monstration - MotivationsAlignmentScorer
Exemples pratiques d'utilisation du nouveau syst√®me de scoring motivationnel
"""

import asyncio
import time
from typing import Dict, Any

# Imports MotivationsAlignmentScorer
from nextvision.engines.motivations_scoring_engine import motivations_scoring_engine
from nextvision.services.job_intelligence_service import job_intelligence_service
from nextvision.models.questionnaire_advanced import MotivationsClassees, QuestionnaireComplet
from nextvision.services.gpt_direct_service import JobData


class MotivationsScoringDemo:
    """D√©monstration compl√®te du syst√®me de scoring motivationnel"""
    
    def __init__(self):
        self.demo_results = []
    
    async def run_complete_demo(self):
        """Ex√©cute tous les exemples de d√©monstration"""
        
        print("üéØ D√âMONSTRATION MOTIVATIONSALIGNMENTSCORER")
        print("=" * 60)
        
        # 1. Exemple basique
        await self._demo_basic_scoring()
        
        # 2. Profils candidats vari√©s
        await self._demo_candidate_profiles()
        
        # 3. Types de jobs diff√©rents
        await self._demo_job_types()
        
        # 4. Analyse intelligence job
        await self._demo_job_intelligence()
        
        # 5. Performance et cache
        await self._demo_performance_cache()
        
        # 6. Int√©gration endpoint simul√©e
        await self._demo_endpoint_integration()
        
        print("\n" + "=" * 60)
        print("üéâ D√©monstration termin√©e avec succ√®s!")
        
        return self.demo_results
    
    async def _demo_basic_scoring(self):
        """D√©monstration du scoring basique"""
        
        print("\nüìã 1. SCORING BASIQUE")
        print("-" * 30)
        
        # Candidat exemple
        motivations = MotivationsClassees(
            classees=["Innovation", "√âvolution", "√âquipe", "Salaire"],
            priorites=[1, 2, 3, 4]
        )
        
        # Job exemple
        job = JobData(
            title="Senior AI Engineer",
            company="TechCorp Innovation",
            benefits=["Formation continue", "R&D budget", "√âquipe agile", "Stock options"],
            responsibilities=["D√©veloppement IA", "Leadership technique", "Innovation produit"]
        )
        
        # Calcul du score
        start_time = time.perf_counter()
        score = await motivations_scoring_engine.calculate_score(
            candidat_motivations=motivations,
            job_data=job
        )
        execution_time = (time.perf_counter() - start_time) * 1000
        
        print(f"Candidat motivations: {motivations.classees}")
        print(f"Job: {job.title} chez {job.company}")
        print(f"Score d'alignement: {score:.3f}")
        print(f"Temps d'ex√©cution: {execution_time:.2f}ms")
        
        self.demo_results.append({
            "demo": "basic_scoring",
            "score": score,
            "execution_time_ms": execution_time
        })
    
    async def _demo_candidate_profiles(self):
        """D√©monstration avec diff√©rents profils candidats"""
        
        print("\nüë• 2. PROFILS CANDIDATS VARI√âS")
        print("-" * 30)
        
        # Job de r√©f√©rence
        reference_job = JobData(
            title="Full Stack Developer",
            company="TechStartup",
            benefits=["T√©l√©travail hybride", "Formation", "Stock options", "√âquipe jeune"],
            responsibilities=["D√©veloppement web", "Collaboration √©quipe", "Innovation continue"]
        )
        
        # Profils candidats vari√©s
        profiles = [
            {
                "name": "Candidat Innovation",
                "motivations": MotivationsClassees(
                    classees=["Innovation", "Technologie", "√âvolution"],
                    priorites=[1, 2, 3]
                )
            },
            {
                "name": "Candidat √âquilibre",
                "motivations": MotivationsClassees(
                    classees=["Flexibilit√©", "√âquipe", "Work-Life Balance"],
                    priorites=[1, 2, 3]
                )
            },
            {
                "name": "Candidat √âvolution",
                "motivations": MotivationsClassees(
                    classees=["√âvolution", "Leadership", "Responsabilit√©s"],
                    priorites=[1, 2, 3]
                )
            },
            {
                "name": "Candidat R√©mun√©ration",
                "motivations": MotivationsClassees(
                    classees=["Salaire", "Avantages", "S√©curit√©"],
                    priorites=[1, 2, 3]
                )
            }
        ]
        
        for profile in profiles:
            score = await motivations_scoring_engine.calculate_score(
                candidat_motivations=profile["motivations"],
                job_data=reference_job
            )
            
            print(f"{profile['name']}: {score:.3f}")
            print(f"  Priorit√©s: {profile['motivations'].classees}")
            
            self.demo_results.append({
                "demo": "candidate_profiles",
                "profile": profile["name"],
                "score": score
            })
    
    async def _demo_job_types(self):
        """D√©monstration avec diff√©rents types de jobs"""
        
        print("\nüíº 3. TYPES DE JOBS VARI√âS")
        print("-" * 30)
        
        # Candidat de r√©f√©rence (orient√© innovation)
        reference_candidate = MotivationsClassees(
            classees=["Innovation", "√âvolution", "Technologie"],
            priorites=[1, 2, 3]
        )
        
        # Types de jobs
        jobs = [
            {
                "name": "Startup Innovation",
                "job": JobData(
                    title="AI Research Engineer",
                    company="InnovLab",
                    benefits=["R&D libre", "Conf√©rences", "√âquipe recherche"],
                    responsibilities=["Recherche IA", "Brevets", "Innovation disruptive"]
                )
            },
            {
                "name": "Corporate Stable",
                "job": JobData(
                    title="Senior Developer",
                    company="BigCorp",
                    benefits=["Salaire √©lev√©", "S√©curit√© emploi", "Formation"],
                    responsibilities=["Maintenance", "Processus √©tablis", "Documentation"]
                )
            },
            {
                "name": "Scale-up Tech",
                "job": JobData(
                    title="Tech Lead",
                    company="GrowthTech",
                    benefits=["Leadership", "Croissance rapide", "Innovation"],
                    responsibilities=["Architecture", "√âquipe", "√âvolution produit"]
                )
            }
        ]
        
        for job_info in jobs:
            score = await motivations_scoring_engine.calculate_score(
                candidat_motivations=reference_candidate,
                job_data=job_info["job"]
            )
            
            print(f"{job_info['name']}: {score:.3f}")
            print(f"  {job_info['job'].title} chez {job_info['job'].company}")
            
            self.demo_results.append({
                "demo": "job_types",
                "job_type": job_info["name"],
                "score": score
            })
    
    async def _demo_job_intelligence(self):
        """D√©monstration de l'analyse d'intelligence job"""
        
        print("\nüß† 4. ANALYSE INTELLIGENCE JOB")
        print("-" * 30)
        
        # Job complexe pour analyse
        complex_job = JobData(
            title="Principal AI Engineer",
            company="TechUnicorn",
            benefits=[
                "T√©l√©travail 100%", "Formation illimit√©e", "Stock options importantes",
                "Budget R&D personnel", "Conf√©rences internationales"
            ],
            responsibilities=[
                "Architecture IA scalable", "Leadership technique √©quipe 15 personnes",
                "Innovation breakthrough", "Collaboration C-level", "Veille technologique"
            ]
        )
        
        # Analyse intelligence
        intelligence = await job_intelligence_service.analyze_job_intelligence(
            job_data=complex_job,
            cache_key="demo_complex_job"
        )
        
        print(f"Job: {complex_job.title}")
        print(f"Culture d√©tect√©e: {intelligence.culture_type}")
        print(f"Niveau innovation: {intelligence.innovation_level}")
        print(f"Potentiel croissance: {intelligence.growth_potential:.2f}")
        print(f"Flexibilit√© t√©l√©travail: {intelligence.remote_flexibility:.2f}")
        print(f"Potentiel leadership: {intelligence.leadership_potential:.2f}")
        print(f"Opportunit√©s apprentissage: {len(intelligence.learning_opportunities)}")
        print(f"Score confiance: {intelligence.confidence_score:.2f}")
        print(f"Temps traitement: {intelligence.processing_time_ms:.2f}ms")
        
        if intelligence.learning_opportunities:
            print(f"Opportunit√©s: {', '.join(intelligence.learning_opportunities[:3])}")
        
        self.demo_results.append({
            "demo": "job_intelligence",
            "culture_type": intelligence.culture_type,
            "innovation_level": intelligence.innovation_level,
            "confidence": intelligence.confidence_score
        })
    
    async def _demo_performance_cache(self):
        """D√©monstration des performances et du cache"""
        
        print("\n‚ö° 5. PERFORMANCE ET CACHE")
        print("-" * 30)
        
        # Job et candidat pour tests
        test_job = JobData(
            title="Software Engineer",
            benefits=["Formation", "√âquipe"],
            responsibilities=["D√©veloppement", "Collaboration"]
        )
        
        test_motivations = MotivationsClassees(
            classees=["Innovation", "√âquipe"],
            priorites=[1, 2]
        )
        
        # Test sans cache (premier appel)
        print("Test sans cache:")
        times_no_cache = []
        for i in range(5):
            start = time.perf_counter()
            score = await motivations_scoring_engine.calculate_score(
                candidat_motivations=test_motivations,
                job_data=test_job,
                job_cache_key=f"perf_test_{i}"
            )
            execution_time = (time.perf_counter() - start) * 1000
            times_no_cache.append(execution_time)
        
        avg_no_cache = sum(times_no_cache) / len(times_no_cache)
        print(f"  Temps moyen: {avg_no_cache:.2f}ms")
        
        # Test avec cache (appels r√©p√©t√©s)
        print("Test avec cache:")
        times_cache = []
        for i in range(5):
            start = time.perf_counter()
            score = await motivations_scoring_engine.calculate_score(
                candidat_motivations=test_motivations,
                job_data=test_job,
                job_cache_key="perf_test_0"  # M√™me cl√© = cache hit
            )
            execution_time = (time.perf_counter() - start) * 1000
            times_cache.append(execution_time)
        
        avg_cache = sum(times_cache) / len(times_cache)
        improvement = avg_no_cache / avg_cache if avg_cache > 0 else 0
        
        print(f"  Temps moyen: {avg_cache:.2f}ms")
        print(f"  Am√©lioration: {improvement:.1f}x")
        
        self.demo_results.append({
            "demo": "performance_cache",
            "avg_no_cache_ms": avg_no_cache,
            "avg_cache_ms": avg_cache,
            "improvement_factor": improvement
        })
    
    async def _demo_endpoint_integration(self):
        """Simulation d'int√©gration dans l'endpoint intelligent_matching"""
        
        print("\nüîó 6. SIMULATION ENDPOINT INT√âGRATION")
        print("-" * 30)
        
        # Simulation requ√™te compl√®te
        mock_request = {
            "questionnaire": QuestionnaireComplet(
                motivations=MotivationsClassees(
                    classees=["Innovation", "√âvolution", "√âquipe"],
                    priorites=[1, 2, 3]
                )
            ),
            "job_requirements": JobData(
                title="Senior AI Engineer",
                company="TechCorp",
                benefits=["Formation continue", "Innovation labs", "√âquipe agile"],
                responsibilities=["D√©veloppement IA", "Leadership", "R&D"]
            ),
            "pourquoi_ecoute": "Recherche nouveau d√©fi innovation"
        }
        
        # Simulation du calcul complet
        start_time = time.perf_counter()
        
        # Scores existants (simulation)
        static_scores = {
            "semantique": 0.62,
            "hierarchical": 0.66,
            "remuneration": 0.735,
            "experience": 0.5,
            "secteurs": 0.7,
            "localisation": 0.92
        }
        
        # Nouveau score motivations
        motivations_score = await motivations_scoring_engine.calculate_score(
            candidat_motivations=mock_request["questionnaire"].motivations,
            job_data=mock_request["job_requirements"]
        )
        
        # Analyse job intelligence
        job_intel = await job_intelligence_service.analyze_job_intelligence(
            job_data=mock_request["job_requirements"]
        )
        
        # Scores combin√©s
        all_scores = {**static_scores, "motivations": motivations_score}
        
        # Pond√©ration adaptative (simulation)
        weights = {
            "semantique": 0.12,      # -3% pour innovation
            "hierarchical": 0.10,
            "remuneration": 0.15,    # -5% pour innovation
            "experience": 0.10,
            "secteurs": 0.15,
            "localisation": 0.15,
            "motivations": 0.23      # +8% pour innovation
        }
        
        # Score final
        final_score = sum(all_scores[comp] * weights[comp] for comp in all_scores.keys())
        
        total_time = (time.perf_counter() - start_time) * 1000
        
        print(f"Requ√™te: {mock_request['job_requirements'].title}")
        print(f"Pourquoi √©coute: {mock_request['pourquoi_ecoute']}")
        print(f"Score motivations: {motivations_score:.3f}")
        print(f"Job culture: {job_intel.culture_type}")
        print(f"Score final: {final_score:.3f}")
        print(f"Temps total: {total_time:.2f}ms")
        print(f"Objectif < 21ms: {'‚úÖ PASS' if total_time < 21 else '‚ö†Ô∏è WARN'}")
        
        # Simulation r√©ponse enrichie
        response = {
            "final_score": round(final_score, 3),
            "component_scores": all_scores,
            "motivations_analysis": {
                "score": round(motivations_score, 3),
                "candidat_priorities": mock_request["questionnaire"].motivations.classees,
                "job_culture": job_intel.culture_type,
                "innovation_level": job_intel.innovation_level,
                "confidence": round(job_intel.confidence_score, 2)
            }
        }
        
        print(f"\nR√©ponse enrichie preview:")
        print(f"  component_scores.motivations: {response['component_scores']['motivations']}")
        print(f"  motivations_analysis.job_culture: {response['motivations_analysis']['job_culture']}")
        
        self.demo_results.append({
            "demo": "endpoint_integration",
            "final_score": final_score,
            "total_time_ms": total_time,
            "performance_target_met": total_time < 21
        })


async def run_demo():
    """Point d'entr√©e principal pour la d√©monstration"""
    
    demo = MotivationsScoringDemo()
    results = await demo.run_complete_demo()
    
    # Affichage r√©sum√©
    print(f"\nüìä R√âSUM√â D√âMONSTRATION")
    print(f"Total d√©mos ex√©cut√©es: {len(results)}")
    
    # V√©rification performance
    perf_results = [r for r in results if "execution_time_ms" in r or "total_time_ms" in r]
    if perf_results:
        avg_time = sum(r.get("execution_time_ms", r.get("total_time_ms", 0)) for r in perf_results) / len(perf_results)
        print(f"Temps moyen d'ex√©cution: {avg_time:.2f}ms")
    
    print(f"üéØ D√©monstration MotivationsAlignmentScorer termin√©e avec succ√®s!")
    
    return results


if __name__ == "__main__":
    print("üöÄ Lancement d√©monstration MotivationsAlignmentScorer...")
    results = asyncio.run(run_demo())
