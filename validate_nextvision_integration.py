#!/usr/bin/env python3
"""
üîç SCRIPT DE VALIDATION POST-CORRECTION NEXTVISION V3.0
Valide que les corrections d'imports ont bien r√©solu les probl√®mes

üéØ OBJECTIF: Confirmer que le score d'int√©gration ‚â• 80%
‚úÖ FOCUS: Validation sp√©cifique des corrections appliqu√©es

Author: Assistant Claude
Version: 3.0.0-validation
"""

import os
import sys
import importlib
import traceback
import subprocess
from pathlib import Path
from typing import Dict, List, Tuple, Optional, Any
import time
from datetime import datetime

class NextvisionIntegrationValidator:
    """üîç Validateur d'int√©gration Nextvision V3.0"""
    
    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root)
        self.nextvision_path = self.project_root / "nextvision"
        
        self.validation_results: Dict[str, bool] = {}
        self.import_tests: Dict[str, bool] = {}
        self.performance_metrics: Dict[str, float] = {}
        self.detailed_errors: List[str] = []
        
        # Tests d'imports critiques
        self.critical_imports = {
            "nextvision.services.google_maps_service": "GoogleMapsService",
            "nextvision.services.transport_calculator": "TransportCalculator",
            "nextvision.services.scorers_v3.location_transport_scorer_v3": "LocationTransportScorerV3",
            "nextvision.services.parsing.commitment_bridge_optimized": "CommitmentParsingBridge",
            "nextvision.services.enhanced_commitment_bridge_v3": "EnhancedCommitmentBridgeV3",
            "nextvision.models.transport_models": "TravelMode",
            "nextvision.models.extended_matching_models_v3": "ExtendedMatchingProfile"
        }
        
        print(f"üîç Validateur d'int√©gration Nextvision initialis√©")
        print(f"üìÅ R√©pertoire projet: {self.project_root.absolute()}")

    def validate_project_structure(self) -> bool:
        """Valide la structure du projet"""
        
        print("üèóÔ∏è VALIDATION STRUCTURE PROJET")
        print("-" * 40)
        
        required_paths = [
            self.nextvision_path,
            self.nextvision_path / "services",
            self.nextvision_path / "services" / "parsing",
            self.nextvision_path / "services" / "scorers_v3",
            self.nextvision_path / "models",
        ]
        
        missing_paths = []
        for path in required_paths:
            if path.exists():
                print(f"‚úÖ {path.relative_to(self.project_root)}")
            else:
                print(f"‚ùå {path.relative_to(self.project_root)} (MANQUANT)")
                missing_paths.append(str(path))
        
        # Fichiers critiques
        critical_files = [
            "nextvision/services/enhanced_commitment_bridge_v3_integrated.py",
            "nextvision/services/google_maps_service.py",
            "nextvision/services/transport_calculator.py",
            "nextvision/services/scorers_v3/location_transport_scorer_v3.py",
            "nextvision/services/parsing/commitment_bridge_optimized.py"
        ]
        
        missing_files = []
        for file_path in critical_files:
            full_path = self.project_root / file_path
            if full_path.exists():
                print(f"‚úÖ {file_path}")
            else:
                print(f"‚ùå {file_path} (MANQUANT)")
                missing_files.append(file_path)
        
        structure_valid = len(missing_paths) == 0 and len(missing_files) == 0
        self.validation_results["structure"] = structure_valid
        
        if structure_valid:
            print("‚úÖ Structure projet valid√©e")
        else:
            print(f"‚ùå Structure incompl√®te: {len(missing_paths)} dossiers, {len(missing_files)} fichiers manquants")
            
        return structure_valid

    def validate_critical_imports(self) -> bool:
        """Valide les imports critiques"""
        
        print("\nüì¶ VALIDATION IMPORTS CRITIQUES")
        print("-" * 40)
        
        # Ajout du r√©pertoire projet au Python path
        project_str = str(self.project_root.absolute())
        if project_str not in sys.path:
            sys.path.insert(0, project_str)
        
        successful_imports = 0
        total_imports = len(self.critical_imports)
        
        for module_name, expected_class in self.critical_imports.items():
            try:
                start_time = time.time()
                
                # Import du module
                module = importlib.import_module(module_name)
                
                # V√©rification de la classe/objet attendu
                if hasattr(module, expected_class):
                    import_time = (time.time() - start_time) * 1000
                    self.performance_metrics[f"import_{module_name}"] = import_time
                    
                    print(f"‚úÖ {module_name}.{expected_class} ({import_time:.2f}ms)")
                    self.import_tests[module_name] = True
                    successful_imports += 1
                else:
                    print(f"‚ùå {module_name}: classe '{expected_class}' non trouv√©e")
                    self.import_tests[module_name] = False
                    self.detailed_errors.append(f"Classe manquante: {module_name}.{expected_class}")
                
            except ImportError as e:
                print(f"‚ùå {module_name}: erreur import - {e}")
                self.import_tests[module_name] = False
                self.detailed_errors.append(f"Import error {module_name}: {e}")
                
            except Exception as e:
                print(f"‚ùå {module_name}: erreur inattendue - {e}")
                self.import_tests[module_name] = False
                self.detailed_errors.append(f"Unexpected error {module_name}: {e}")
        
        imports_valid = successful_imports >= total_imports * 0.9  # 90% de r√©ussite minimum
        self.validation_results["imports"] = imports_valid
        
        print(f"\nüìä R√©sultat imports: {successful_imports}/{total_imports} ({(successful_imports/total_imports)*100:.1f}%)")
        
        return imports_valid

    def validate_no_circular_imports(self) -> bool:
        """Valide l'absence d'imports circulaires"""
        
        print("\nüîÑ VALIDATION IMPORTS CIRCULAIRES")
        print("-" * 40)
        
        # Test import du bridge int√©gr√© (anciennement probl√©matique)
        try:
            start_time = time.time()
            
            from nextvision.services.enhanced_commitment_bridge_v3_integrated import (
                EnhancedCommitmentBridgeV3Integrated,
                IntegratedBridgeFactory
            )
            
            import_time = (time.time() - start_time) * 1000
            print(f"‚úÖ Enhanced Bridge V3 Int√©gr√© import√© ({import_time:.2f}ms)")
            
            # Test instanciation
            bridge = IntegratedBridgeFactory.create_development_integrated_bridge()
            print("‚úÖ Bridge int√©gr√© instanci√©")
            
            self.validation_results["circular_imports"] = True
            return True
            
        except ImportError as e:
            print(f"‚ùå Import circulaire d√©tect√©: {e}")
            self.detailed_errors.append(f"Circular import: {e}")
            self.validation_results["circular_imports"] = False
            return False
            
        except Exception as e:
            print(f"‚ùå Erreur bridge int√©gr√©: {e}")
            self.detailed_errors.append(f"Bridge error: {e}")
            self.validation_results["circular_imports"] = False
            return False

    def validate_model_consistency(self) -> bool:
        """Valide la coh√©rence des mod√®les (ex: TravelMode vs TravelMode)"""
        
        print("\nüéØ VALIDATION COH√âRENCE MOD√àLES")
        print("-" * 40)
        
        try:
            # Test TravelMode (nouveau mod√®le)
            from nextvision.models.transport_models import TravelMode
            
            # V√©rification √©nums
            expected_modes = ['DRIVING', 'TRANSIT', 'WALKING', 'BICYCLING']
            available_modes = [mode.name for mode in TravelMode]
            
            missing_modes = [mode for mode in expected_modes if mode not in available_modes]
            
            if len(missing_modes) == 0:
                print(f"‚úÖ TravelMode complet: {available_modes}")
                self.validation_results["model_consistency"] = True
                return True
            else:
                print(f"‚ùå TravelMode incomplet: manque {missing_modes}")
                self.validation_results["model_consistency"] = False
                return False
                
        except ImportError as e:
            print(f"‚ùå Mod√®le transport non trouv√©: {e}")
            self.detailed_errors.append(f"Transport model: {e}")
            self.validation_results["model_consistency"] = False
            return False

    def validate_service_instantiation(self) -> bool:
        """Valide l'instanciation des services principaux"""
        
        print("\nüõ†Ô∏è VALIDATION INSTANCIATION SERVICES")
        print("-" * 40)
        
        successful_services = 0
        total_services = 3  # Nombre de services critiques
        
        # Test Google Maps Service
        try:
            from nextvision.services.google_maps_service import GoogleMapsService
            service = GoogleMapsService("test_key")
            print("‚úÖ GoogleMapsService instanci√©")
            successful_services += 1
        except Exception as e:
            print(f"‚ùå GoogleMapsService: {e}")
            self.detailed_errors.append(f"GoogleMapsService: {e}")
        
        # Test Transport Calculator
        try:
            from nextvision.services.transport_calculator import TransportCalculator
            calculator = TransportCalculator()
            print("‚úÖ TransportCalculator instanci√©")
            successful_services += 1
        except Exception as e:
            print(f"‚ùå TransportCalculator: {e}")
            self.detailed_errors.append(f"TransportCalculator: {e}")
        
        # Test Location Transport Scorer
        try:
            from nextvision.services.scorers_v3.location_transport_scorer_v3 import LocationTransportScorerV3
            scorer = LocationTransportScorerV3()
            print("‚úÖ LocationTransportScorerV3 instanci√©")
            successful_services += 1
        except Exception as e:
            print(f"‚ùå LocationTransportScorerV3: {e}")
            self.detailed_errors.append(f"LocationTransportScorerV3: {e}")
        
        services_valid = successful_services >= total_services * 0.8  # 80% de r√©ussite
        self.validation_results["service_instantiation"] = services_valid
        
        print(f"\nüìä Services: {successful_services}/{total_services} ({(successful_services/total_services)*100:.1f}%)")
        
        return services_valid

    def run_integration_test(self) -> Tuple[bool, float]:
        """Lance le test d'int√©gration officiel"""
        
        print("\nüß™ LANCEMENT TEST INT√âGRATION OFFICIEL")
        print("-" * 40)
        
        test_file = self.project_root / "test_integration_simple.py"
        
        if not test_file.exists():
            print("‚ùå test_integration_simple.py non trouv√©")
            return False, 0.0
        
        try:
            # Lancement test avec timeout
            result = subprocess.run([
                sys.executable, str(test_file)
            ], capture_output=True, text=True, timeout=180)
            
            # Analyse sortie
            output = result.stdout + result.stderr
            
            # Extraction score
            import re
            match = re.search(r'Taux de r√©ussite: (\d+\.?\d*)%', output)
            if match:
                score = float(match.group(1))
            else:
                # Estimation bas√©e sur les succ√®s/√©checs
                success_count = output.count('‚úÖ')
                total_count = max(output.count('TEST:'), 7)  # 7 tests attendus
                score = (success_count / total_count) * 100 if total_count > 0 else 0
            
            test_success = result.returncode == 0 and score >= 80.0
            
            if test_success:
                print(f"‚úÖ Test int√©gration r√©ussi: {score:.1f}%")
            else:
                print(f"‚ö†Ô∏è Test int√©gration partiel: {score:.1f}% (code: {result.returncode})")
                
                # Affichage erreurs si disponibles
                if result.stderr:
                    print("Erreurs d√©tect√©es:")
                    for line in result.stderr.split('\n')[:5]:  # Premi√®res erreurs
                        if line.strip():
                            print(f"  ‚Ä¢ {line.strip()}")
            
            self.validation_results["integration_test"] = test_success
            return test_success, score
            
        except subprocess.TimeoutExpired:
            print("‚è±Ô∏è Test timeout (>3min) - possibles imports bloquants")
            self.validation_results["integration_test"] = False
            return False, 0.0
            
        except Exception as e:
            print(f"‚ùå Erreur test: {e}")
            self.validation_results["integration_test"] = False
            return False, 0.0

    def calculate_integration_score(self) -> float:
        """Calcule le score d'int√©gration final"""
        
        # Pond√©ration des validations
        weights = {
            "structure": 0.15,           # 15% - Structure projet
            "imports": 0.25,             # 25% - Imports critiques
            "circular_imports": 0.20,    # 20% - Absence imports circulaires
            "model_consistency": 0.15,   # 15% - Coh√©rence mod√®les
            "service_instantiation": 0.15, # 15% - Services instanciables
            "integration_test": 0.10     # 10% - Test int√©gration
        }
        
        total_score = 0.0
        
        for validation, passed in self.validation_results.items():
            if validation in weights:
                contribution = weights[validation] * (100 if passed else 0)
                total_score += contribution
                print(f"  {validation}: {'‚úÖ' if passed else '‚ùå'} ({contribution:.1f} points)")
        
        return total_score

    def generate_action_plan(self, score: float) -> List[str]:
        """G√©n√®re un plan d'action bas√© sur les validations √©chou√©es"""
        
        actions = []
        
        if not self.validation_results.get("structure", False):
            actions.append("üèóÔ∏è Restaurer structure projet: fichiers/dossiers manquants")
        
        if not self.validation_results.get("imports", False):
            actions.append("üì¶ Corriger imports critiques: v√©rifier chemins modules")
            actions.append("üîß Lancer: python3 fix_nextvision_imports_final.py")
        
        if not self.validation_results.get("circular_imports", False):
            actions.append("üîÑ R√©soudre imports circulaires: enhanced_commitment_bridge_v3_integrated.py")
            actions.append("üõ†Ô∏è Transformer h√©ritage en composition")
        
        if not self.validation_results.get("model_consistency", False):
            actions.append("üéØ Corriger mod√®les: TravelMode ‚Üí TravelMode")
        
        if not self.validation_results.get("service_instantiation", False):
            actions.append("üõ†Ô∏è Corriger instanciation services: v√©rifier d√©pendances")
        
        if score < 80.0:
            actions.append("üß™ Relancer validation: python3 validate_nextvision_integration.py")
            actions.append("üìä Objectif: atteindre score ‚â• 80%")
        
        return actions

    def run_complete_validation(self) -> Tuple[bool, float]:
        """Lance la validation compl√®te"""
        
        print("üîç VALIDATION COMPL√àTE INT√âGRATION NEXTVISION V3.0")
        print("=" * 60)
        
        start_time = time.time()
        
        # Validation par √©tapes
        validations = [
            ("Structure Projet", self.validate_project_structure),
            ("Imports Critiques", self.validate_critical_imports),
            ("Imports Circulaires", self.validate_no_circular_imports),
            ("Coh√©rence Mod√®les", self.validate_model_consistency),
            ("Instanciation Services", self.validate_service_instantiation)
        ]
        
        # Ex√©cution validations
        for validation_name, validation_func in validations:
            try:
                validation_func()
            except Exception as e:
                print(f"‚ùå Erreur validation {validation_name}: {e}")
                self.validation_results[validation_name.lower().replace(" ", "_")] = False
                self.detailed_errors.append(f"{validation_name}: {e}")
        
        # Test int√©gration final
        test_success, test_score = self.run_integration_test()
        
        # Calcul score final
        validation_score = self.calculate_integration_score()
        
        # Score final (moyenne pond√©r√©e)
        final_score = (validation_score * 0.7) + (test_score * 0.3)
        
        # Rapport final
        end_time = time.time()
        duration = end_time - start_time
        
        print("\n" + "=" * 60)
        print("üìä RAPPORT VALIDATION FINAL")
        print("=" * 60)
        
        print(f"‚è±Ô∏è Dur√©e validation: {duration:.2f}s")
        print(f"üì¶ Imports test√©s: {len(self.critical_imports)}")
        print(f"üõ†Ô∏è Validations effectu√©es: {len(self.validation_results)}")
        
        print(f"\nüìä SCORES:")
        print(f"  ‚Ä¢ Score validation: {validation_score:.1f}%")
        print(f"  ‚Ä¢ Score test int√©gration: {test_score:.1f}%")
        print(f"  ‚Ä¢ Score final: {final_score:.1f}%")
        
        # D√©tail des validations
        print(f"\nüîç D√âTAIL VALIDATIONS:")
        self.calculate_integration_score()  # Affiche le d√©tail
        
        # Statut final
        success = final_score >= 80.0
        
        if success:
            print(f"\nüéâ VALIDATION R√âUSSIE! Score: {final_score:.1f}% (‚â• 80%)")
            print("‚úÖ Int√©gration Nextvision V3.0 fonctionnelle")
            print("‚úÖ Imports correctement r√©solus")
            print("‚úÖ Services instanciables")
            print("\nüöÄ Prochaines √©tapes:")
            print("1. Tests complets: python3 test_nextvision_commitment_integration.py")
            print("2. D√©mo Transport Intelligence: python3 demo_transport_intelligence.py")
            print("3. D√©ploiement: python3 deploy_nextvision_v2.sh")
            
        else:
            print(f"\n‚ö†Ô∏è VALIDATION PARTIELLE. Score: {final_score:.1f}% (< 80%)")
            
            # Plan d'action
            actions = self.generate_action_plan(final_score)
            if actions:
                print("\nüîß PLAN D'ACTION:")
                for i, action in enumerate(actions, 1):
                    print(f"{i}. {action}")
        
        # Erreurs d√©taill√©es
        if self.detailed_errors:
            print(f"\n‚ùå ERREURS D√âTAILL√âES ({len(self.detailed_errors)}):")
            for i, error in enumerate(self.detailed_errors[:10], 1):  # Premi√®res 10
                print(f"{i}. {error}")
            if len(self.detailed_errors) > 10:
                print(f"   ... et {len(self.detailed_errors) - 10} autres erreurs")
        
        print("=" * 60)
        
        return success, final_score

def main():
    """Point d'entr√©e principal"""
    
    # V√©rification environnement
    if not Path("nextvision").exists():
        print("‚ùå Dossier 'nextvision' non trouv√©.")
        print("Ex√©cutez ce script depuis le r√©pertoire racine du projet Nextvision.")
        sys.exit(1)
    
    # Lancement validation
    validator = NextvisionIntegrationValidator()
    
    try:
        success, score = validator.run_complete_validation()
        
        # Code de sortie
        if success:
            sys.exit(0)  # Succ√®s complet
        elif score >= 60.0:
            sys.exit(1)  # Succ√®s partiel
        else:
            sys.exit(2)  # √âchec
            
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Validation interrompue par l'utilisateur")
        sys.exit(3)
    except Exception as e:
        print(f"\n‚ùå Erreur critique validation: {e}")
        traceback.print_exc()
        sys.exit(4)

if __name__ == "__main__":
    main()
